<?xml version="1.0" ?>
<!DOCTYPE bulletml SYSTEM "../barrage.dtd">

<barrage>

<!--
2004/4/23 by Oohara Yuuma (oohara@libra.interq.or.jp)
* ebony sky
* glacial chasm
* static world
-->

<barrageInfo>
  <filename>lilac</filename>
  <group>Oohara</group>
  <title>ライラック</title>
  <description>魔法使いは火力が全てです。</description>
  <capture>横に撃たせて外側へ、これ最強。ただし巻きこまれてしまったら正面突破のほうがいいです。</capture>
  <author>Oohara_Yuuma</author>
</barrageInfo>

<barrageStyle>
  <bulletLanguage name="lua"/>
</barrageStyle>

<lua>
<![CDATA[
---
--- subroutines for BulletML compatibility start
---

function dtor(d)
  return 2.0 * math.pi * d / 360.0
end

function rtod(r)
  return 360.0 * r / (2.0 * math.pi)
end

function fire_absolute(d, speed)
  local r = dtor(d - 90.0)
  if (speed < 0.0001) then
    return
  end
  fire(speed * math.cos(r), speed * math.sin(r))
end

function fire_absolute_f(d, speed, func)
  local r = dtor(d - 90.0)
  if (speed < 0.0001) then
    return
  end
  fire(speed * math.cos(r), speed * math.sin(r), func)
end

function fire_aim(d, speed)
  local r = dtor(d)
  local dx = getPlayerX() - getX()
  local dy = getPlayerY() - getY()
  local d_length = dx * dx + dy * dy
  local v_x = 0.0
  local v_y = 0.0
  if (speed < 0.0001) then
    return
  end
  if (d_length < 0.0001) then
    fire_absolute(360.0 * math.random(), speed)
    return
  end
  d_length = math.sqrt(d_length)
  dx = dx / d_length
  dy = dy / d_length
  v_x = speed * (dx * math.cos(r) - dy * math.sin(r))
  v_y = speed * (dx * math.sin(r) + dy * math.cos(r))
  fire(v_x, v_y)
end

function fire_aim_f(d, speed, func)
  local r = dtor(d)
  local dx = getPlayerX() - getX()
  local dy = getPlayerY() - getY()
  local d_length = dx * dx + dy * dy
  local v_x = 0.0
  local v_y = 0.0
  if (speed < 0.0001) then
    return
  end
  if (d_length < 0.0001) then
    fire_absolute_f(360.0 * math.random(), speed, func)
    return
  end
  d_length = math.sqrt(d_length)
  dx = dx / d_length
  dy = dy / d_length
  v_x = speed * (dx * math.cos(r) - dy * math.sin(r))
  v_y = speed * (dx * math.sin(r) + dy * math.cos(r))
  fire(v_x, v_y, func)
end

function fire_relative(d, speed)
  local r = dtor(d)
  local dx = getSpeedX()
  local dy = getSpeedY()
  local d_length = dx * dx + dy * dy
  local v_x = 0.0
  local v_y = 0.0
  if (speed < 0.0001) then
    return
  end
  if (d_length < 0.0001) then
    fire_absolute(360.0 * math.random(), speed)
    return
  end
  d_length = math.sqrt(d_length)
  dx = dx / d_length
  dy = dy / d_length
  v_x = speed * (dx * math.cos(r) - dy * math.sin(r))
  v_y = speed * (dx * math.sin(r) + dy * math.cos(r))
  fire(v_x, v_y)
end

function fire_relative_f(d, speed, func)
  local r = dtor(d)
  local dx = getSpeedX()
  local dy = getSpeedY()
  local d_length = dx * dx + dy * dy
  local v_x = 0.0
  local v_y = 0.0
  if (speed < 0.0001) then
    return
  end
  if (d_length < 0.0001) then
    fire_absolute_f(360.0 * math.random(), speed, func)
    return
  end
  d_length = math.sqrt(d_length)
  dx = dx / d_length
  dy = dy / d_length
  v_x = speed * (dx * math.cos(r) - dy * math.sin(r))
  v_y = speed * (dx * math.sin(r) + dy * math.cos(r))
  fire(v_x, v_y, func)
end

function fire_point(target_x, target_y, d, speed)
  local r = dtor(d)
  local dx = target_x - getX()
  local dy = target_y - getY()
  local d_length = dx * dx + dy * dy
  local v_x = 0.0
  local v_y = 0.0
  if (speed < 0.0001) then
    return
  end
  if (d_length < 0.0001) then
    fire_absolute(360.0 * math.random(), speed)
    return
  end
  d_length = math.sqrt(d_length)
  dx = dx / d_length
  dy = dy / d_length
  v_x = speed * (dx * math.cos(r) - dy * math.sin(r))
  v_y = speed * (dx * math.sin(r) + dy * math.cos(r))
  fire(v_x, v_y)
end

function fire_point_f(target_x, target_y, d, speed, func)
  local r = dtor(d)
  local dx = target_x - getX()
  local dy = target_y - getY()
  local d_length = dx * dx + dy * dy
  local v_x = 0.0
  local v_y = 0.0
  if (speed < 0.0001) then
    return
  end
  if (d_length < 0.0001) then
    fire_absolute_f(360.0 * math.random(), speed, func)
    return
  end
  d_length = math.sqrt(d_length)
  dx = dx / d_length
  dy = dy / d_length
  v_x = speed * (dx * math.cos(r) - dy * math.sin(r))
  v_y = speed * (dx * math.sin(r) + dy * math.cos(r))
  fire(v_x, v_y, func)
end

---
--- subroutines for BulletML compatibility end
---

function onestep(origin_x, origin_y, angle, i_begin, theta)
  local i = i_begin
  local x = 0.0
  local y = 0.0
  local target_x = 0.0
  local target_y = 0.0
  while (i < 360) do
    x = origin_x + 30.0 * math.cos(dtor(i) + angle)
    y = origin_y + 30.0 * math.sin(dtor(i) + angle)
    target_x = origin_x - 100.0 * math.sin(angle) + 45.0 * math.cos(dtor(i + theta) + angle)
    target_y = origin_y + 100.0 * math.cos(angle) + 60.0 * math.sin(dtor(i + theta) + angle)
    setPos(x, y)
    fire_point(target_x, target_y, 0.0, (1.0 + 0.4 * math.sin(dtor(i))) * (0.5 + 0.5 * getRank()))
    fire_point(target_x, target_y, 0.0, (1.5 + 0.2 * math.sin(dtor(i))) * (0.5 + 0.5 * getRank()))
    i = i + 9
  end
end

function top()
  local origin_x = getX()
  local origin_y = getY()
  local angle = getPlayerAngle() - dtor(180)
  if (getTurn() > 600 - 200 * getRank()) then
    quit()
  end
  if (not (getTurn() == 60)) then
    return
  end
  onestep(origin_x, origin_y, angle, 3, 90)
  onestep(origin_x, origin_y, angle, 6, -90)
  onestep(origin_x, origin_y, angle, 0, 180)
  setPos(origin_x, origin_y)
end
]]>
</lua>

</barrage>
